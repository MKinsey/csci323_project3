var orbitable = angular.module('orbitable', ['d3'])
    .directive('d3Bodies', ['$window', '$timeout', 'd3Service',
        function($window, $timeout, d3Service) {
            return {
                restrict: 'EA',
                scope: {
                    bodies: '=',
                    viewport: '=',
                    currentBody: '=',
                    running: '='
                },
                link: function(scope, ele, attrs) {
                    d3Service.d3().then(function(d3) {

                        var renderTimeout;
                        var sizeFactor = parseFloat(attrs.sizeFactor) || 1,
                            heightTrim = parseInt(attrs.heightTrim) || 260,
                            minZoom = parseFloat(attrs.minZoom) || 0.2,
                            maxZoom = parseFloat(attrs.maxZoom) || 8;

                        svg_c = d3.select(ele[0])
                            .append('svg')
                            .style('width', '100%');

                        var svg = svg_c.append("g");

                        window.zoom = d3.behavior.zoom();

                        function updateViewport(scale, translate) {
                            svg.attr("transform", "translate(" + translate + ") scale(" + scale +")");
                        }

                        svg_c.call(window.zoom.scaleExtent([minZoom,maxZoom]).on("zoom", function() {
                                    scope.$apply(function() {
                                            scope.viewport = {zoom: d3.event.scale, translation: d3.event.translate};
                                        });
                                    prepareToDeselect = false;
                                    updateViewport(d3.event.scale, d3.event.translate);
                                }));

                        var length = 0;

                        var prepareToDeselect = false;

                        $window.onresize = function() {
                            scope.$apply();
                        };

                        scope.$watch(function() {
                            return angular.element($window)[0].innerHeight;
                        }, function() {
                            svg_c.style('height', window.innerHeight - heightTrim);
                            scope.render(scope.bodies);
                        });

                        scope.$watch('bodies', function(newData) {
                                if(newData) {
                                    if (newData.length != length) {
                                        scope.render(newData);
                                        length = newData.length;
                                    }
                                    scope.updateRender(newData);
                                }
                        }, true);

                        scope.$watch('viewport.zoom', function(newZoomFactor) {
                                var oldScale = window.zoom.scale();
                                window.zoom.scale(newZoomFactor);
                                var height = window.innerHeight - heightTrim;
                                var width = svg_c.node().getBoundingClientRect().width;
                                var c = [width / 2, height / 2];
                                var t = zoom.translate();
                                window.zoom.translate([c[0] + (t[0] - c[0]) / oldScale * newZoomFactor, c[1] + (t[1] - c[1]) / oldScale * newZoomFactor]);
                                updateViewport(window.zoom.scale(), window.zoom.translate());
                            }, true);
                        scope.$watch('viewport.translation', function(newTrans) {
                                window.zoom.translate(newTrans);
                                updateViewport(window.zoom.scale(), window.zoom.translate());
                            }, true);

                        scope.updatePositions = function(circles) {
                            circles.attr("cx", function(d) {
                                return d.x
                            });
                            circles.attr("cy", function(d) {
                                return d.y
                            });
                            circles.attr("r", function(d) {
                                return Math.sqrt(d.m * sizeFactor)
                            });
                            return circles;
                        };

                        scope.drag = d3.behavior.drag().origin(function(d) { return d }).on("dragstart", function(d) {
                                d3.event.sourceEvent.stopPropagation();
                            }).on("drag", function(d) {
                                    if(!scope.running) {
                                        scope.$apply(function() {
                                        var myCircle = d3.select(this);
                                        d.x = d3.event.x;
                                        d.y = d3.event.y;
                                            });
                                    }
                            }).on("dragend", function() {

                            });

                        scope.updateRender = function(data) {
                            var circleData = svg.selectAll("circle").data(data);
                            scope.updatePositions(circleData);
                        };

                        scope.render = function(data) {
                            svg.selectAll('*').remove();
                            if (!data) return;
                            if (renderTimeout) clearTimeout(renderTimeout);

                            renderTimeout = $timeout(function() {
                                var masses = data.map(function(d) {
                                    return d.m;
                                });

                                var circle = svg.selectAll("circle").data(data);
                                var circleEnter = circle.enter().append("circle");
                                circleEnter.attr("fill", function(d){
                                    return d.c
                                }).call(scope.drag);
                                circleEnter.on("mousedown", function(d) { d3.event.stopPropagation(); console.log("clicked", d); d3.selectAll("circle").style("fill", function(d){ return d.c }); d3.select(this).style("fill", "orange"); prepareToDeselect = false; scope.$apply(function() { scope.currentBody = d; }) });
                                circleEnter.on("touchstart", function(d) { d3.event.stopPropagation(); console.log("clicked", d); d3.selectAll("circle").style("fill", "black"); d3.select(this).style("fill", "orange"); prepareToDeselect = false; scope.$apply(function() { scope.currentBody = d; }) });
                                svg_c.on("mousedown",function() {prepareToDeselect = true});
                                svg_c.on("touchstart",function() {prepareToDeselect = true});
                                svg_c.on("mouseup",function() {if(prepareToDeselect) {console.log("clicked");svg.selectAll("circle").style("fill", function(d){ return d.c }); scope.$apply(function() { scope.currentBody = null; });}});
                                svg_c.on("touchend", function() {if(prepareToDeselect) {console.log("clicked");svg.selectAll("circle").style("fill", "black"); scope.$apply(function() { scope.currentBody = null; });}});
                                scope.updatePositions(circleEnter);
                            });
                        };
                    });
                }
            }
        }
    ]);

/*bodyData = [{
    id: 0,
    x: 50,
    y: 20,
    m: 10
}, {
    id: 1,
    x: 100,
    y: 20,
    m: 20
}, {
    id: 2,
    x: 150,
    y: 20,
    m: 30
    }];*/

bodyData = [];
